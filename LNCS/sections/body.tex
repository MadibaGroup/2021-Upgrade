% !TEX root = ../main.tex

% = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

\section{Introductory Remarks}



\section{Classification}
% We have some off-chain upgrades like what people did to force UNISwap using arbitrum as the L2 solution. It is an off-chain upgrade not an automated one.
% Does Factory patterns can be defined as upgradeability patterns? Like creating a new pool for Uniswap!
\subsection{Retail Changes}
This is not a standardized pattern. The development team must consider the ways to upgrade the contracts before deploying the smart contract. Known patterns are different on the level of intervention to change the logic that they need to change in the future. The amount of changes are limited and system design can not be changed after deployment and just some system variables can be changed. We will describe three famous patterns here:

\paragraph{Parameter Configuration}. The easiest way to upgrade the logic of the smart contract is to have some critical parameter that can change the whole logic of the system. For instance, in economy we have different variables which have effect in the interest rates. By changing those variables the governors will response to changes needed for the system. 
In this model we have a setter function to change the upgradable parameters if the system needs upgrades. The best example for this type of upgradeability is MakeDao project. In Maker there are some variables like Dai Saving Rate (DSR) or Stability fee that can be changed through governance vote. The logic behind the smart contract and the tokenomic of the Dapp completely depends on these variables.

\paragraph{Strategy pattern}. The strategy pattern is an easy way for changing part of the code in a contract responsible for a specific feature. Instead of implementing a function in your contract to take care of a specific task, you call into a separate contract to take care of that – and by switching implementations of that contract, you can switch between different strategies.
An example for this pattern is Compound project and how they used strategy pattern for their interest rate model. There is a interest rate model contract in Compound that can be changed during the time. 

\paragraph{Pluggable Modules}. In this pattern we have a core contract that have some immutable features and then new contracts generated by the main contract and each have some or all features of the main contract. This pattern is mostly used in wallets and DeFi services like DeFi saver and InstaDapp. Users can decide to add new features into their wallet. 

%TODO: Ask shayan about DeFi save and how do they upgrade their contracts.
\subsection{Wholesale Changes}
In contrast to previous session, sometime we need to change the whole or a big part of the logic of our smart contract. This update could be a response to an incident happen to the smart contract or a planed upgrade of the system. Before deployment, the core developer team should have a plan for the upgrade events. We categorized these types into two main classes:

\subsubsection{Contract Migration}
%who will push the old data? user to provide its own data to the new version?
In the migration plan we should write a completely new contract with our desired new logic. In migration method our new version contract doesn't have any communication with the previous versions. The challenges we face in migration method are:
\begin{enumerate}
    \item Grab the needed data (from previous contract or new data): 
    It depends on the data type. It is easy for simple data structures (\eg uint, address, or even arrays) to collect the data just by reading storage slots from the 0 slot. we should take care of complex structures (\eg mapping) in the latest versions of our contract by adding event updates whenever a data added to a mapping variable. In case of an upgrade we can use Logs to find storage slot (using key hash) and collect the data.
    Sometime we need to push new data into our upgraded smart contract. For example in airdrops we need new coin to be added to some specific addresses. 
    \item Push the data into the new contract: 
    Using Constructor, we can use batch transfer function with arrays of addresses and amounts as inputs. This way we can push lots of data using a single transaction. One limitation here is block gas limit. If we exceeds the block gas limit we need to push all data in different blocks (pausing in the first block and unpause at the end). Recently, Devs are using merkle distribution tree to push data on to the smart contracts.
    The most important thing here is the cost of pushing data to the new version. It depends on 1)the number of storage slots to be updated and 2)Method used to push the data on-chain. (Can be tested). 
    \item Stop the previous contract:
    Suppose that we have a token contract and we want to migrate to a new version. We should be confident that nobody can use the previous contract. If not, it is possible that a person sell a token from previous contract (which should be valueless after migration) to a person who doesn't aware of the migration plan.Because of the decentralized nature of the blockchain and Dapps you cannot reach to your customers to alert them from using the previous contract. One way to do that is have a pause option the your contracts and pause the old versions before migration.
  \end{enumerate}

Contract Migration is less riskier than other types of upgrades, not cost effective compare to some upgradeability types but more decentralized to the other solutions. Also, it's not good for frequent updates.The other advantage of this method is that it removes transaction gas cost needed for patterns like proxy, registry or call-based methods.

%https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/
% Migration 300,000 balances = $7500 in october 2018


\subsubsection{diamonds}
\subsubsection{Create2-based approach}

\subsubsection{Data Separation patterns}
The other type of wholesale methods is to separate data and logic part of our codes. In the case of the upgrade we can  keep the storage contract and just upgrade the logic contract and link the new version of logic contract to the storage contract.
There is a debate on whether this type of upgradeability is cheaper or not in comparison to migration method. But, this method is more efficient for Dapps in which we need frequent updates. The other important issue here is who decides on the changes we need for the system which we will discuss on further sections.
Here we have 2 different choices using Call method and Delegate Call method to link storage and logic contracts together.

\paragraph{Call based patterns}

In this type the interaction between logic and storage contact is handle by Call opcode in Ethereum Virtual Machine. In call based patterns user is supposed to call the logic contract and the logic contract will call the storage contract. The logic contract is the one that can be upgraded.

There are two concerns in this approach: how to store data and how to perform an upgrade.

\textit{Storage. } The easiest way to store data in storage contract is to have a modifier on the setter functions in the storage contract that allow just the logic contract to change the variables. The owner of the contract can change the address of logic contract for the modifier.
In this approach for adding a new persistent variable, a new data contract should be deployed which may be costly in case that the application needs lots of upgrades.

The other way to store data is so called Eternal storage (ERC930). Eternal storage uses mapping (key-value pair) to store data, using one mapping per type of variable. The EVM storage layout and how it handles mapping helps the Eternal storage pattern to be more amenable to evolution but also more complex.

\textit{Upgrade implementation. } There are three main ways to implement upgrades using data separation pattern. The easiest way is to change the ownership of storage contract into new upgraded logic contract and then \textbf{Pause} the old contract or set its pointer to 0x0 address. The other solution is to forward the calls receive by the old contract into the new logic contract. The last option is to set a proxy contract that just keeps the address of logic contract and call into logic contract.

% \textit{Risks. } (From trail of bits blog)
% "We have repeatedly seen clients deploy this pattern incorrectly. For example, one client’s implementation achieved the opposite effect, where a feature was impossible to upgrade because some its logic was located in the data contract.

% In our experience, developers also find the EternalStorage pattern challenging to apply consistently. We have seen developers storing their values as bytes32, then applying type conversion to retrieve the original values. This increased the complexity of the data model, and the likelihood of subtle flaws. Developers unfamiliar with complex data structures will make mistakes with this pattern."


\paragraph{DelegateCall-based upgrades}
Similar to call based patterns here we have two contracts, Storage and Logic contract. we may have more than one logic contract. The difference here is that the user is calling storage contract first(called proxy contract), and the proxy contract DelegateCalls to the logic contract(s).
The main difference between delegatecall and call-based approach is that in delegatecall proxy pattern the storage layout of proxy and logic contract should be the same. The difference between storage layouts will result in storage clashes. 
There are three different methods to mitigate the risk of storage clashes:

\textit{Inherited Storage}. 
In this method the proxy contract and all logic contracts are inherited from a storage contract that contains storage variables. Using this method we are confident that the proxy and logic contracts are using the same storage layout and storage clashes will be mitigated.
After deployment if we need new logic contract with new storage variables, we should deploy a new storage contract that inherits the previous storage contract. Then the new logic contract must inherit the new version of the storage contract.

This method is not efficient because of variables that declared but not used in some logic contracts. On the other hand, each logic contract is coupled with a storage contract and it is hard to take care of this track. 

\textit{Eternal Storage}. 
In this pattern, we defined mappings for all variable types that we need to use in our logic smart contract. For storing mapping variables EVM selects random slots on the storage based on the variable's name so we can mitigate the clashes using this randomness.

The main problem of this type is that the logic contract and all other contracts that are using the storage must use the mapping structure to access the storage variables and use complex syntax whenever they want to access a variable. This also results in the gas usage inefficiency because we need to call and update a mapping each time we need to change a variable.  

Also it is hard to use eternal storage for complex variables like mappings and structure (need mapping of mapping pattern). Also finding a state variable of the proxy smart contract is hard because we store them in arbitrary slots of the storage.
%  we cannot add new state variables using this method.

\textit{Unstructured Storage}. 
The other way of mitigating the storage clashes is to assign some randomly selected slots to critical variables like address of logic contract. For instance, open zeppling uses hash of "org.zeppelinos.proxy.implementation" to store the address of the logic contract in this slot.

The downside of this approach is that we need getter and setter function for each variable. We also can use unstructured storage for simple variables and not for mapping and structures.



\begin{figure}
  \centering
    
      \includegraphics[width=0.9\textwidth]{figures/Chart.png}
  \caption{Classification}
 \end{figure}

 \section{Evaluation of different methods}
 
 In this section we compare and evaluate different methods discussed in previous section. There are some characteristics that can help the designer to decide which method should be used on the system and add upgradeability to the Dapp.

 For our evaluation framework, we provide the definition of each evaluation criteria (i.e., column of the table), specifying what it means to receive a check mark (\checkmark) or nothing.

 %separate rows
% \subsection{Extent of Upgradeability}
 
 
 
\subsubsection{Can replace entire logic}

An upgradeability method in which the upgrader is able to replace the entire logic of the system earns a check mark(\checkmark) otherwise it receives nothing.

\subsubsection{can replace pre-specified part of logic}

An upgradeability method in which the upgrader can change \emph{just} pre-specified part of logic of the system (and not entire logic) earns a check mark(\checkmark) otherwise it receives nothing.

\subsubsection{Can replace entire state}

An upgradeability method that gives the upgrader ability to replace or transfer the entire state to the newer version earns a check mark(\checkmark) otherwise it receives nothing.

\subsubsection{can change pre-specified state variables}
 
An upgradeability method in which the upgrader can just change some pre-specified state variables receives a check mark (\checkmark) otherwise it awarded nothing.
 

 % JC: Be more precise about "whole logic" and "part". This can be broken into sub-columns if necessary. Start by defining the parts of a DApp: logic, state, etc. Then properties can be "Can replace logic" "Can replace state" "Can set state variables" (I don't know for sure, this is just ideas). This column is super important so make it as precise as you can. 
 


%  \textit{Retail Change} methods limit the the upgrades to a small part of the system (\Circle). However, using \textit{Migration}, \textit{Call-based} and \textit{DelegateCall-based} approaches, the upgrader is able to deploy a new smart contract with a new set of functions and logics.
%Add rows:
% Parameter change: can State variable change
% Strategy pattern: can part of Logic change


%%%%%%%%%%%%
% \subsection{Upgrade Frequency} \label{upgradeFRQ}
%%%%%%%%%5

\subsection{No need to deploy a new contract}

Using some upgradeability patterns, the upgrader needs to deploy a new smart contract in the process of upgrade which receives nothing. Upgradeability methods which do not need to deploy a new contract receive a check mark (\checkmark).

\subsection{No need to migrate state from old contract}

In some patterns, the upgrader needs to collect and transfer old data from previous version to the newer one which receive nothing (\checkmark) otherwise it receives a check mark (\checkmark). 
% JC: I would start the clock at "decision to upgrade" rather than proposal (otherwise is depends on how decisions are made). Also is single transaction the right metric? I can write an upgrade helper contract to do all the steps in a single function call. I think it could be better as: do you have to push a NEW contract? Do you have to change (more than one?) EXISTING contracts?

% An upgradeability method that can move from proposal to finality within a single transaction is awarded a full dot (\CIRCLE). A process that requires more than a single block time in order to write and deploy a new logic contract receives half circle (\LEFTcircle). A method that needs more than just deploying a new logic contract and changing some parameters awarded empty circle (\Circle).

% The upgrader can process the whole upgrade using \textit{Retail changes} method in a single transaction time window after proposing the change (\CIRCLE). On the other hand, \textit{Call-based} and \textit{DelegateCall-based} approaches are more time consuming because the upgrader needs a time window to write the new logic contract, deploy it to the mainnet, and change some address pointers (\LEFTcircle). \textit{Migration} method is more time consuming and not good for frequent changes because Before the upgrade the developers need to collect data of old contract (\eg getting storage snapshot), write a new version of the logic smart contract, and push the old data into the newer version which is time consuming and sometimes it takes multiple blocks to push all data from the old version (because of block gas limit of a block) (\Circle).
 %%%%%%%%%%
%  \subsection{System Complexity}
 %%%%%%%%%%%%%
\subsection{No need to separate State and Logic}

An upgradeability pattern that does not requires separation of logic and storage contracts awarded a check mark (\checkmark) otherwise it receives nothing.

\subsection{Not using DelegateCall opcode}

Some of the upgradeability methods utilize \textit{Delegate call} opcode. Using  this opcode bring complexity to the system and needs more security considerations (\eg checking storage layout compatibility). Upgradeability methods that do not need to use delegate call opcode receive a check mark (\checkmark) otherwise it awarded nothing. 
 % JC: Not crazy about this column. It is not clear if it is a feature or a bug. I also don't really understand it. Forced to change it isn't clear. "Considerations to smart contract security" doesn't make sense to me. Try expanding on these ideas a bit or we can discuss in a call. 
 
%  Applying each upgradeability method has different complexity effects on the system. An upgradeability method in which the designer do not need to change any logic of the contract receives empty circle (\Circle). Upgradeability methods that cause changing the whole design or the logic of the smart contract but do not add possible security flaws or attack surfaces receive half circle (\LEFTcircle). Upgradeability methods that force the developer to change the whole logic of the smart contract and adds considerations to smart contract security receives full circle (\CIRCLE).

%  \textit{Migration} method does not add any complexity to the system. The system designer do not need to change considerable part of system design to have feature to migrate to the new version before deployment. So, it is the less complex choice that a designer can take (\Circle).
 
%  In \textit{Retail changes} method, it is hard and complex for system designers to design a system in which a parameter or a small part of system can change the logic of the system and be safe to change it but it does not add security considerations (\LEFTcircle).
 
%  In the \textit{Call-based} upgradeability approach, the system designer must separate storage and logic pieces of the contract and change the whole design of the smart contract. It adds complexity to the system to be confident that these two are separated correctly. But it does not add considerable new attack surfaces to the system (\LEFTcircle).
 
 
%  On the other hand, \textit{DelegateCall-based} patterns adds more complexity to the system because of using DelegateCall opcode as well as need to separating logic and storage contract. The main difference between \textit{Call-based} and \textit{DelegateCall-based} approach is that the developer should take care that using Delegatecall opcode needs to take care that the logic and storage contract must have similar storage layout. So using DelegateCall pattern changes the design of the contract and adds new attacks surfaces to the system (\CIRCLE).

 \subsection{No indirection}
 
 % JC: This is good. You can add more precision though. If I want to call function A, and I call B which calls A, it is called a "layer of indirection." Can this be phrases in terms of the number of layers of indirection for users? No indirection (full), one or more layers of indirection (empty).  
 
 Upgradeability methods that do not need any redirection receive a check mark (\checkmark).An upgradeability pattern that adds an extra gas because of adding one or more layers of indirection awarded nothing. An upgradeability method in which just a portion of its transactions need indirection receive square (\XBox). 

\textit{Retail Changes} and \textit{Migration} methods do not add any indirections to the system so will not alter the transaction costs (\checkmark). However, \textit{Call-based} and \textit{DelegateCall-based} approaches increase the transaction cost for users (receive nothing). \textit{Call-based} method will increase the transaction cost because whenever a transaction needs to add or change a data, the logic contract must \textbf{CALL} the storage contract which adds an extra gas. Also in \textit{DelegateCall-based} approach all transactions will be \textbf{Delegate Called} to the logic contract using a \textbf{proxy} which adds an extra gas on each transaction. 

\textcolor{red}{We need a comparison between Call based and Delegate call based approaches (if possible. I think Call based approach is gas efficient for systems that do not need to add or change data frequently. Also there are other extra adds-on that can add useability but adds gas like adding feature for uninformed users in Call based approaches.)}
% TODO: nice article: https://forum.openzeppelin.com/t/a-more-gas-efficient-upgradeable-proxy-by-not-using-storage/4111

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  \subsection{Cost of Upgrade}
%  % JC: This column merges two seperate ideas: do you have to deploy a new contract? That can be a column. Do you have to migrate the state from the old contract to the new contract? That can be a second column. 

%  One of the main differences between upgradeability approaches is how much does the upgrade process costs. An upgradeability pattern that costs like a normal transaction (\eg changing a parameter or a more complex variables like structures) receives an empty circle (\Circle). Upgradeability methods that needs to deploy a new logic contract but do not need to push old data into it receive half circle (\LEFTcircle) and patterns in which the upgrader should deploy a new logic contract and push old data into the new version is the most expensive approach in the upgrading process and awarded full circle (\CIRCLE).
 


%%%%%%%%%%%%%%%%%
%  \subsection{Useability}
%%%%%%%%%%%%%%%%%
% JC: This still vague. Be very precise. Alice uses DApp at address A before the upgrade. After upgrade, she can be unaware that upgrade happened. She uses address B instead. The function names have all changed. What else are "some actions in addition"? Give specific examples. (New ability can be added to upgrade which is not user friendly)

\subsection{User endpoint address not changed}
\textcolor{red}{The title could be: \textit{Having 2 Dapps at the end} ?!}
% Both are the same I think
%For instance in Uniswap we have 2 dapps at the end but can we say user should use a new address or not? maybe these 2 are not the same?
%which kind of users are we talking about? client users or like other smart contracts?!
In some upgradeability methods, after the upgrade process, users must call a new contract address to use the Dapp. For instance, Alice uses a DApp at address A before the upgrade. After upgrade, she can be unaware that upgrade happened or she may need to use address B instead (\checkmark).

%We may have another row for a call-based pattern that uses a "registry like patterns" to not change user end point

\subsection{Users do not require taking some action (withdraw deposit)}
\textcolor{red}{The title could be: \textit{Users are involved? (Client)} ?!}

In some upgradeability patterns, users are responsible to transfer their related data from the previous version to the new one. In some others, users do not need to take any further actions like this (\checkmark)). 
%Need to check for the Migration plans to find out if there is any other thing that users may do for the migration other than the withdraw deposit

%  An upgradeability approach in which users do not feel any changes and do not need to take any action after the upgrade process receives a full circle (\CIRCLE). In patterns that the users just need to call a new smart contract address rewarded a half circle (\LEFTcircle). In some patterns although the users should take some actions in addition to using a new address (\Circle).    
 
%  In \textit{Retail Change} approach the user does not feel the upgrade process unless she has a exposure to the parameter that is changing on the upgrade (\CIRCLE).
%  In \textit{Call-based} method, the logic contract (the contract that is called by users) will be changed. So, users must call a new contract after the upgrade which is not user friendly (\LEFTcircle). There are some approaches to mitigate this by using a proxy contract in between. The other way to mitigate this is to implement a way in which an old logic smart contract can call the newer version and pass the user's request to the newer version. These solutions add an extra gas to each transaction which is not usable as well.
% In \textit{DelegateCall-based} approach users are calling the proxy contract which delegate call their request to the whitelisted logic contract. In the upgrade event the developers change the whitelisted address to the new version but users call the proxy like before. So, users do not feel the upgrading process (\CIRCLE).

% On the other hand, users in a \textit{Migration} plan need to work with a new smart contract . In some Migration plans, users themselves must withdraw their fund from the previous version and deposit it on the new version which is not user friendly and costly for them (\Circle).

% %%%%%%%
%  \subsection{Fixing a Bug}
 %%%%%%%%%
%  \subsection{Remove this}

%  % JC: What is it about the contract that does or does not allow a bug to be fixed. Is it just a question of whether you can change the logic of the DApp? In that case, is it already captured by the proposed column above? 
 
% As mentioned in the previous part, upgradeability could be used in two different situations; adding new features or fixing a bug. An upgradeability pattern that cannot be used for fixing a bug receives square (\XBox). An upgradeability pattern which can be used for fixing a bug but not suitable for fixing a bug receives an empty circle (\Circle) and the methods which are suitable for fixing a bug receives a full circle (\CIRCLE).

% In an incident, \textit{Retail Changes} approach won't help to response to a bug or hack because the extent of upgradeability is limited and the developers are not able to change the required parts of the system (\XBox). \textit{Migration} is not proper as well because it is not quick enough to respond in a limited time window.
% On the other hand, \textit{Call-based} and \textit{DelegateCall-based} are very well for fixing a bug. In the event, the developers can find the root cause and patch it by deploying a new contract and change the implementation address in the logic contract. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\subsection{Change pattern after deployment}

\textcolor{red}{Migration is the only way to add upgradeability feature to out smart contract}

% This can be used for EOA, Multi-sig and governance



%TODO: Talk about the outcomes:
% for instance: 
% Usabality: this method is not usable because it changes the user endpoint address and need withdraw and deposit and bla bla ...
% Fixing a bug: ...
% Upgrade cost: .....
% Speed of upgrade: ....
% Level of decentralization: 


% \subsection{Pauseability}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Speed of an Upgrade}
 
 % JC: I would split this into speed of reaching a decision to upgrade, and speed to implement the upgrade once the decision is made. The second one maybe is already well-covered by previous columns though. I'm not worried about this and the next column this week. Let's work on the other ones first. 
 
Another difference between upgradeability methods is the speed in which an upgrade can be processed. This depends on the type of decision makers which will be discussed in~\ref{decisionMakers}. 

\textit{Retail changes} method is the fastest way to upgrade a system comparing to other methods. Using an EOA as the decision maker is the fastest option of an upgrade. Using multi-sig is a bit slower than using EOA. Utilizing a decentralized governance scheme to decide about upgrades will put an inherit time delay to the upgrades.

\textit{Migration} has the slowest upgrade process between other methods. The reasons are discussed in the previous parts (see~\ref{upgradeFRQ}).

\textit{Call-based} and \textit{DelegateCall-based} are very similar to each other in the speed of upgrade. These two are not as quick as \textit{Retail changes} because the developer needs to find the root cause of a bug or find the upgrades needed for system and then implement the smart contract and deploy it to the system which is time consuming.
On the other hand these two approaches are faster than \textit{Migration} because as mentioned before, in Migration plans we need to collect and push old data into newer version as well.  

 \subsection{Level of Decentralization}

The last and one of the most important characteristics that are different in upgradeability methods is the level of decentralization. An upgradeability methods that a single third party decides the upgrading process receives a square (\XBox). 
Using an \textbf{EOA} to decide about a change is the most central option that a system designer can choose regardless of the upgradeability method uses in the system. 
In case a group of whitelisted persons can decide on the changes orf the system using \textbf{Multi-sig} is not decentralized as well. Although it improves the level of decentralization of the system but at the end a specified number can decide to change the system. So it awarded an empty circle (\Circle).

Utilizing a decentralized governance model to vote for a change is a good way to make the decision making on the upgrades more decentralized. \textit{Retail Changes} using voting scheme is more decentral than \textit{Call-based} and \textit{DelegateCall-based} because boundary of changes are limited on the Retail methods so it awarded a full circle (\CIRCLE). But, in CAll-based and DelegateCall based methods the developers have the power to put some kind of backdoor in the system while upgrading and they receive a half circle (\LEFTcircle). 

The \textit{Migration} method is the most decentralized approach because it gives the users chance to decide whether to move to the newer version or not so it awarded a full circle (\CIRCLE). For instance, Uniswap uses this method for its upgrade and the users have choice to transfer their funds from Uniswap V2 to V3 or not and as we can see some users decide to stay on the previous version.

% • Efficiency: gas for those uninformed about upgrades
% • Efficiency: gas for those informed about upgrades

 % talk about vulnerabilities of each here
% Exploit on Aave caused by initialize function (Alternative to constructor) https://blog.trailofbits.com/2020/12/16/breaking-aave-upgradeability/

 \section{Upgrading process}
  

 \subsection{decision maker(s)} \label{decisionMakers}
 There is a debate on who is responsible for upgrading a Dapp. Different systems can choose one of these schemes to upgrade their Dapp depending on the complexity of the system, frequency of the changes needed for the system and how fast does the system need to upgrade in the incidents.
%History of changing from not having a single owner to then owner and then Multi-sig and then Decentralized voting
 \subsubsection{Externally owned Address}
The easiest and the fastest way to upgrade a system is through a single address which is the owner of smart contract. This is the most centralized solution we have for upgrading a system. The main problem with this issue is the security of the system because it only depends on a single private key hold by the owner. In case of malicious party or if an attacker find the owner's private or if the owner lose the key the entire system is on the risk.

First Dapps on the ethereum blockchain used this method for the upgrade but it is not used these days because it is far from the idea of \textit{Decentralization}. 

 \subsubsection{Multi-Sig}
 A \textit{m out of n} Multi-sig wallet is a smart contract that can manage a transactions only if m number out of a specified n EOAs agree and sign the transaction. We can use address of a Multi-sig wallet as the owner of the system. In case of a upgrade or responding to an incident m number of the governors can permit to upgrade the system.

 This is a better answer to the decision making of the upgrade compare to using an EOA in case of centrality while keeping the speed of an upgrade process. However, it is not decentralized. One way to reduce the level of centralization is to use different trusted teams who are stakeholders of the system in the multi-sig wallet. 


\subsubsection{Governance Voting}
The most decentralized way to decide on a system change is to do it using decentralized voting. This can be done by distributing governance voting tokens to the community and then they can vote on a change proposal by staking their voting token. 

There are some critique to this method. Governance by voting has an inherit time delay to the upgrading process. This raises a problem when the system needs an instant upgrade (\eg responding to an incident). This means we need another mechanism to quickly fix bugs and upgrade the system on the event of incidents in conjunction with the voting process (\eg Global shutdown in MakerDAO).

It is also not cost-efficient for the voters because all token holders must send a transaction and needs to pay network fee.

The other problem with this method is fair distribution of the tokens. If the governance token does not distribute fairly and the majority of tokens granted to the limited number of users, then it is very similar to the multi-sig method which is more costly and complex. Because, whales of the governance token can vote to any desired change of the system similar to the multi-sig.
 

\subsection{Mitigating risks}
There are critical setups on the systems to mitigate the possible risks on the upgrading process. We mention some of them here with risk associated with them.

\subsubsection{Timelocks}
In some project, there is a time window between every changes that approved on the system and when they affect the system. This gives opportunity to the users who are not satisfied with the upcoming upgrades to move their funds out of the system. However this is not proper in case of fixing a bug, because we need to patch the problem quickly.

\subsubsection{Thereshold}
In multi-sig and governance upgrade methods we need a threshold on votes to decide whether a change is approved or not. This threshold should be big enough to be confident that upgrading event represents the majority of opinions. On the other hand, the threshold shouldn't be that big because a big threshold will delay a system change. The system designer should consider that a portion of voters (signers in multi-sig or governance token holders in voting method) may not be available in the event of the upgrade and having a big threshold may result in halting the change proposal for a long period of time. In fact threshold has a trade-off between security/decentralization and speed of the upgrade process.

\subsubsection{Pausable}
In pauseable smart contracts, the decision makers (usually a multi-sig wallet) can freeze some or all operations of the system. Pausing a smart contract helps in some specific situations:

\begin{enumerate}
  \item Time to react to a bug or hack: usually it takes time to analyze and find the reason of a hack and patch the bug. In this time period the core developer team needs to pause the system to stop attacker from draining all the fund.
  \item Halting system in the upgrade process: For instance, in an ERC20 token contract upgrade we need to pause the system to stop users from transferring tokens during the upgrade. 
  \item Inactivating the previous version of the logic contracts: After an upgrade we need to have a plan to stop users from using the previous logic contracts. One way to do so is to make the logic contracts pauseable and pause them after the upgrade. 
\end{enumerate}

\subsubsection{Escape Hatches}
A escape hatch is a mechanism that lets the users to move their fund out of the system in the pausing events. For instance, in MakerDAO we have an emergency shutdown mechanism that pauses the system in the black swan events. But, users have the ability to extract their funds out of the system while the system is paused.
\subsubsection{Front-Runnign}
Upgrading a smart contract can be done by sending a transaction into the system. If the upgrade is a response to a unknown bug, then the upgrade process will hint attackers who is listening to the mempool to find the bug and hack the smart contract just before the upgrade. So there should be some mechanisms to mitigate front-running attacks. One solution to this issue is to use commit-reveal schemes. The team first sends a commitment of the upgrade (hash of the upgrade) to the system and after the timelock they can push and apply the original code which cannot be front run. 
%Commit reveal



% upgrading in dark: https://forum.makerdao.com/t/mip15-dark-spell-mechanism/2578


 \section{Measurement study}

 In this section we aim to shed light on these vital unanswered questions: 
 \begin{enumerate}
  \item How many of the existing Dapps on the Ethereum blockchain are upgradeable?
  \item Who can control these upgradeable Dapps (i.e who is the admin)? 
  \item In what extent the Dapp can be changed?
  \item What is the average frequency of updates on the Ethereum Dapps?
  \item How many times the admin of upgradeable contracts changes on average?
\end{enumerate}
 
For now, we focused on the \textit{DelegateCall-based upgrade} pattern because it is the most favorite pattern for Dapp developers (\textcolor{red}{We can have 2 approaches here. One is to find a way to prove that this is the most used approach. The second way is to try to find a way to have measurement study for other patterns. I think the first approach is better because some of the other approaches are dead and nobody uses them anymore (like Call-based approach) and the others (like parameter change approach) is impossible to catch.})

There are three main methodology types to have a research on Ethereum blockchain; Transaction-based analysis, Bytecode based analysis and Etherscan Verified Smart Contracts based analysis. The first and second methodologies need to access to an Ethereum full archival node. But the last approach need to collect smart contracts from a third party service named Etherscan.io in which the Dapp developers are able to put their high-level language smart contracts which will be checked and verified from the bytecode of the Dapp on the Ethereum blockchain.

\subsection{Verified Smart Contract Based Analysis}
In the first attempt we conducted a measurement study based on verified smart contracts on Etherscan to find instances of OpenZeppelin upgradeable proxy contracts. OpenZeppelin is a team that built well-known libraries for ethereum developers. One of the most famous libraries of the OpenZeppelin is their upgradeability plugins. There two different versions of the OpenZeppelin upgrade libraries; version 2.6 and version 3+. 
We used smart-contract-sanctuary~\cite{smart_contract_sanctuary} which is a data set of all ethereum smart contracts verified on Etherscan. 

To find the smart contracts which used different versions of the OpenZeppelin upgradeability library, two different approaches are used. First, we used an Abstract Syntax Tree (AST) based similarity detector: Solidity Doppelgaenger~\cite{solidity-doppelganger}. We found 143 smart contract that used version 2.6 and 125 version 3+ OpenZeppelin upgrade libraries. 

In another attempt, we used Regular Expression (regex) to find if the smart contracts on our data set used the interface (function and variable used on the code) of the each version of the OpenZeppelin libraries. The unique interface that used in each version of the OpenZeppelin libraries helps us to find them just by checking the interface. We found 922 contracts using V2.6 and 309 contracts using V3+. All results from AST-based detection was found on the interface detection results. So we used the results from interface detection for the rest of this part.

Now that we have the address of upgradeable smart contracts we can check how many times the upgrade happened for each and how many times the admin of the upgradeable contract is changed. For this purpose, OpenZeppelin libraries have used Ethereum Events on the functions in which the upgrade happens (Event "Upgraded) and the admin changes (Event "AdminChanged) and emitted when the events happened. We capture these events for each contract address using Etherscan Ethereum Log API service.

\begin{figure}[t]
  \centering
      \subfloat[OpenZeppelin V2.6]{\includegraphics[width=0.45\columnwidth]{figures/UpgradeV26.png}\label{fig:upgradev26}}
      \qquad
      \subfloat[OpenZeppelin V3+]{\includegraphics[width=0.45\columnwidth]{figures/upgradev3.png}\label{fig:upgradev3}}
  \caption{Number of Dapps (y-axis) over number of upgrades (x-axis) \label{fig:upgrade}}
\end{figure}
\begin{figure}[t]
  \centering
      \subfloat[OpenZeppelin V2.6]{\includegraphics[width=0.45\columnwidth]{figures/Adminv26.png}\label{fig:adminv26}}
      \qquad
      \subfloat[OpenZeppelin V3+]{\includegraphics[width=0.45\columnwidth]{figures/Adminv3.png}\label{fig:adminv3}}
  \caption{Number of Dapps (y-axis) over number of Admin Changes (x-axis) \label{fig:admin}}
\end{figure}
The results for each version is:
\begin{itemize}
  \item For V2.6 (922 contracts):
  \begin{itemize}
    \item Upgrade Happens (see figure~\ref{fig:upgradev26}):
    \begin{itemize}
      \item 110 with One Upgrade, 60 with Two Upgrade, 2 with 20 upgrades, 5 with Five upgrade, 4 with 7 Upgrades, 3 with 10,12,15,16 Upgrades, 1 with 16 upgrades
    \end{itemize}
    \item Admin Change Happens (see figure~\ref{fig:upgradev3}):
    \begin{itemize}
      \item 57 with One Change, 14 with Two change, 4 with Three change, 1 with 4 changes, 1 Dapp with 5, 6,7,9 Changes
    \end{itemize}
  \end{itemize}
  \item For V3+ (309 contracts):
  \begin{itemize}
    \item Upgrade Happens (see figure~\ref{fig:adminv26}):
    \begin{itemize}
      \item 30 with One Upgrade, 10 with Two Upgrade, 4 with Three upgrade, 2 with 4 Upgrades, 3 with 5 Upgrades, 2 with 7 Upgrades
    \end{itemize}
    \item Admin Change Happens (see figure~\ref{fig:adminv3}):
    \begin{itemize}
      \item 11 with One Change, 1 with Two change
    \end{itemize}
  \end{itemize}
\end{itemize}


\textcolor{red}{There are some other measurement studies there like Pausable tokens which I skiped for now and we can add them as well}



\subsection{Hybrid Analysis (Transaction and Bytecode based)}
As mentioned in classification section, the \textit{DelegateCall-based upgrade} approach is consists of a storage contract (a.k.a proxy contract) and a logic contract (a.k.a Implementation contract). 

Proxy contract is a simple type of smart contracts in which there is a fall back function. Fall back functions are \textit{Payable} functions that do not have a function name. It means if a user sends a transaction to the contract including a call to a function that does not exists on the contract, it will passed into the fall back function and the logic on the fall back function will be executed. Also because of \textit{Payable} nature of fall back functions if the user sends Ether into a smart contract the fall back function will be executed.

Inside the fall back function of the proxy contracts, there is a delegate call to the address of \textit{Implementation contract} and pass the input data of the transaction to the implementation contract without altering it. 

All proxy contracts have the above structure. But \textit{Upgradeable proxy contracts} should have another extra condition as well. The owner of the contract (a.k.a admin) must have the ability to change the address which the proxy contract delegate calls into. If a proxy does not have this condition, it means that the contract is just forwarding the calls into a fixed implementation contract for the rest of its life and so, this proxy is not upgradeable. There are bunch of patterns that follows this structure (e.g. Minimal Proxies, Delegate call forwarders, etc.) which we call them \textit{Forwarders} in the rest of the paper.

\subsubsection{Methodology}
In this section we describe the processes of finding upgradeable proxy contracts from scratch. Each block of Ethereum blockchain is consist of transactions that processed in that exact block. To get all transaction details we need to replay the transaction and collect the execution data. Ethereum full archival nodes have a method, \textit{trace\_transaction},  that gives the transaction traces of transactions inside an specific block. Each transaction trace is composed of actions that each of them consists of an opcode that changes the state, memory or stack of the Ethereum blockchain. 

Having the transaction traces for each block, we will search to find actions that consists of \textit{callType} and the call type is \textit{delegate call}. If the input element (a.k.a call data) of these actions are equal to the input element of their previous action it will be interpreted as the transaction goes through a fallback function that delegate calls it to another contract. So, these contracts meet our first condition that described above and we will mark them as \textit{Proxy Contracts}. We will collect \textit{From address},\textit{To address} and the \textit{transaction hash} of these picked actions and pick the unique from addresses of this data.

As discussed before, these picked contracts are proxy contracts and not necessarily upgradeable proxy contracts. So, we need to filter the forwarders from proxy contracts to have upgradeable proxy contracts. As mentioned above, the upgradeable proxy contracts must have a condition; the admin of the contract should be able to change the implementation address which proxy contract delegate calls to. In other words, we should check if the implementation address in the proxy contract is changeable or not.

Four different cases is possible for the situation that the implementation address is fixed and not changeable on the contract:
\begin{enumerate}
  \item The address is hardcoded on the contract without assignment to a variable
  \item The address is saved on a constant variable 
  \item The deployer adds the address via a constructor function
  \item The address is defined in a storage variable, but there is no way to change this address after deployment
\end{enumerate} 

In the first three situations, the address will be appeared on the bytecode of the smart contract. So, we can get the bytecode of the each collected proxy contract using the \textit{eth\_getCode} method of a Ethereum archival node. Then we need to check if the implementation address of the proxy contract is appeared on the bytecode or not. The \textit{To addresses} that we collected on the previous part is supposed to be the implementation addresses because these are the target addresses of the delegate call. So we easily checked if the To addresses is appeared on the bytecode of the From addresses contract. If yes, the addresses are not upgradeable proxies and these are simple forwarder contracts.

For the situation 4, we need other processes to check whether the implementation address is changeable or not. We need to design a filter to tell us is there a way to change the implementation address of the proxy contract or not. We will describe the filter in the later part of the paper, but for now let's assume that we have a software that checks if there is a function on the proxy contract that the admin of the contract can change the implementation address of the proxy by calling the function, and if yes mark the contract as an upgradeable proxy contract. So, now we have output addresses that their contract has fall back functions that delegate calls the whole data into another implementation contract and the address of the implementation is changeable on the proxy contract. So, we have a dataset of proxy contracts.

But this is not the end of story. There is another proposed upgradeable proxy contract pattern, named Universal Upgradeable Proxy Standard (UUPS) also known as EIP-1822. In this type of proxy contracts, the address of implementation address in the proxy contract, is changeable using the implementation smart contract. As mentioned above the code of the implementation contract is implemented in the context of the proxy contract and so it will change the storage state of the proxy contract. If we have a function in the implementation contract that gives us the ability to change the storage slot of the implementation address in the proxy contract, we can upgrade the system by calling that function of implementation contract. So, we couldn't catch these type of upgradeable contracts by the previous processes because we just checked if there is a function on the proxy contract that can change the implementation address.

We can tackle this problem by first finding the storage slot of the proxy contract in which the implementation address is saved, and check if the admin of the implementation contract can alter the variable of the that specific storage slot using a function in the implementation contract. So first we should find the storage slot of the proxy contract in which the implementation address is saved. There are two EIPs out there that makes it easy to find these storage slots; EIP-1967 \footnote{0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc} and EIP-1822 \footnote{0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7}.suggested randomly selected storage addresses for implementation addresses to mitigate the overwriting on these slots. (\textcolor{red}{I can find the storage slot from the proxy contract but it needs us to check lots of contracts which needs high resources and with the existing resources it is not doable so I limited it to these EIPs which I think it's enough})

Now we will check the remained proxy contracts, if the variable that holds implementation address, is not saved on one of the mentioned slots, we will mark it as a forwarder. Now we should check whether the implementation address in the proxy contract is changeable via implementation contract. As mentioned before, the To addresses are the implementation contracts. We first find the variable in the implementation contract that is saved in the mentioned slots. Then pass it to our filter to check if the admin of the contract is able to change it or not. If it is changeable, it means that the admin can upgrade the system using a function on the implementation contract, and so the proxy is an upgradeable proxy contract.

The whole process is depicted on figure~\ref{fig:finderModule}.

\begin{figure*}[t]
  \includegraphics[width=1.2\textwidth]{figures/Finder_module.png}\label{fig:finderModule}
  \caption{Upgradeability Proxy Contract Finder}
\end{figure*}

\paragraph{Assignment Checker Module}

As mentioned in the previous part, we need a module to check if the admin can change the implementation address on the proxy contract or implementation contract. For this purpose we need a module that gets \textit{{Bytecode}} of the proxy/implementation address as input and find the variable name and storage slot of the variable that the implementation address is saved into it. Afterwards check is there any function inside the contract that gives the admin the ability yo change the implementation address.

As the first action we used a bytecode decompiler named \textit{Panoramix decompiler} to decompile the bytecodes into well-formated python language codes. The decompiled code gives us all storage variables and their storage slots in a function named \textbf{Storage}. On the other hand, the decompiled code will tell us if a function is \textit{Payable} or not. Among these Payable functions the one that does not have name or it's name is fallback is the fall back function of the contract. So we will try to find the line that \textit{Delegate Call} happened on it and collet these lines. Now that we have storage variable names and storage slots of them and also the line of code inside fallback that have the delegatecall, we will check to find the implementation address variable. We are doing that by checking if one of the storage variables are inside the line of code or there is a hash a text is inside the line of the code (if there is 'sha3' inside the line). 

There is two other steps here. First if there is a variable name if the Storage function that has the same slot with implementation variables we captured from previous part we will add those variables to implementation variables. Also if the find another variables that being assigned to captured implementation addresses, we will add them to the implementation addresses as well.

Now that we have a list for implementation variables, we will search through the code to find if any assignment happened to one of them. If yes we will pick the variable that is assigned to implementation variable and then check if this picked variable is the input of the function in which the assignment occurred.

To summarize what we did, we find all possible variables in the code that can change the implementation address of the proxy/implementation contract and check if there is any function inside them that can alter the implementation address.

The whole process is depicted on figure~\ref{assignmentFinder}.

\begin{figure*}[t]
  \includegraphics[width=1.2\textwidth]{figures/Assignment_finder.png}\label{assignmentFinder}
  \caption{Assignment CheckerModule}
\end{figure*}

\subsubsection{Results}
Having access to an Ethereum full archival node we have collected transaction traces of transactions included in 50,000 blocks of Ethereum blockchain, starting from block number \textit{\#12814595} to \textit{\#12864595}. It covers transactions on the Ethereum blockchain from \textit{Jul-20-2021} to \textit{Jul-12-2021} (8 days period). 

Having transaction traces and the actions of each transaction, we have collected From address, To address and Transaction Hash of actions which has \textit{delegateCall} as their \textit{Call Type} that their input is the same as their previous action. This resulted in \textit{2.7 millions} of unique transactions that passed a proxy contract.
To have the proxy contract, we find the unique From addresses from all collected transactions which gives us \textit{69,000} unique proxy contracts. 

Filtering \textit{Forwarder Contracts} from our data set by checking if the To address appears on the contract's bytecode gave us \textit{21,200} proxy addresses. \textit{16,000} of these addresses are upgradeable proxy contracts because their implementation addresses is changeable inside their code. By sample checking these addresses we found out that Opensea project \footnote{\url{opensea.io/}} creates an upgradeable proxy for each new user. So we filtered these proxy contracts to have upgradeable proxies other than opensea and the outcome is \textit{1,948} upgradeable proxy contracts. 

On the other hand, we checked \textit{5,040} remained proxy contracts that if their implementation address is based on EIP-1822 or EIP-1967 proposed storage slots. On these selected contracts we picked their implementation address contract and check if the implementation address is able to change the implementation address on the proxy contract, if yes we mark the address as upgradeable proxy contract. The outcome of this last filter is \textit{150} upgradeable proxy contracts that uses Universal Upgradeable Proxy Pattern. 

At the end we have \textit{2,098} upgradeable proxy contracts. We randomly sampled 150 contracts from these 2,098 contracts and manually check them and all of them were upgradeable proxy contract. On the other hand, we sampled 150 contracts from the contracts that marked as non-upgradeable contracts and check them manually. between these 150 contract just two of them was upgradeable and it was a false-negative. The reason that our model did not catch this contract was the wired pattern that the developers used to assign a new value to the implementation address which our assignment detector could not catch it. 

\begin{figure*}[t]
  \includegraphics[width=1.2\textwidth]{figures/sankeyDiagram.png}\label{sankey}
  \caption{Sankey Diagram of results}
\end{figure*}


The results are depicted on a sankey diagram \ref{sankey}


% Level of intervention of each Dapp (pauseable etc.)
% History of upgrades --> How many times a Dapp upgraded before (using events etc...)

% \section{Concluding Remarks}


% \subsection{Registry pattern}
% Registry contracts are probably the simplest approach to upgradeability. Registry pattern consist of two main contracts: registry and logic contract. Registry contract holds the addresses of logic contracts and whenever it receives a transaction it will pass it to the related logic contract. 
% If the development team decide to upgrade the smart contract, they can deploy another smart contract and then just change the pointer of the registry smart contact to the new smart contract.

% The main disadvantage of this approach is that in upgrading event, there should be a manual or automated migration plan to transfer data from the old contract into the new upgrade smart contract.
% Another drawback of this pattern is that it also introduces additional complexity for external clients who would also need to call into the registry before interacting with the system


%Idea: see how frequent each project uses its upgradeability feature to upgrade the contract and why?

%In proxy storage layout you should take care that: 
% 1. never remove variable
% 2. never change var type
% 3. never change inheritance order


%Implementation of Eternal storage in call based upgrades: https://medium.com/cardstack/upgradable-contracts-in-solidity-d5af87f0f913
% Good classificaton: https://medium.com/1milliondevs/solidity-storage-layout-for-proxy-contracts-and-diamonds-c4f009b6903
% New storage type *Dimond Storage*: https://medium.com/1milliondevs/new-storage-layout-for-proxy-contracts-and-diamonds-98d01d0eadb
%https://medium.com/1milliondevs/new-storage-layout-for-proxy-contracts-and-diamonds-98d01d0eadb
% Upgradability checklist: https://blog.trailofbits.com/2020/06/12/upgradeable-contracts-made-safer-with-crytic/



%ToDo: Write about OpenZeppelin upgrade bug : https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/
%ToDo: Gas cost comparison between different implementation (using different number and types of the storage variables)


\section{discussion}
%\subsection{Off chain upgrades (UNiswap Arbitrum)}: On-chain voting for an off-chain process. Other types of upgrade. Like front end changes etc.

\input{sections/table}